load_module modules/ngx_http_cache_purge_module.so;

user nginx;
worker_processes 2;
error_log         "/opt/bitnami/openresty/nginx/logs/error.log" info;
pid               "/opt/bitnami/openresty/nginx/tmp/nginx.pid";

events {
    worker_connections 65536;
}

env SECDN_APIKEY_DIR;
env MINIO_SECRET_KEY;

http {
    lua_package_path "/opt/bitnami/openresty/nginx/lua/?.lua;;";
    # lua_code_cache off; # this will hurt performance
    lua_shared_dict secrets 1m;
    init_worker_by_lua_block {
        local dir = os.getenv("SECDN_APIKEY_DIR")
        local auth = require("api_key_auth")
        local ok, err = auth.load(dir)
        if ok then
            ngx.log(ngx.INFO, "[init_worker] API keys loaded and cached")
        else
            ngx.log(ngx.ERR, "[init_worker] failed to load API keys: ", err)
        end

        local key = os.getenv("MINIO_SECRET_KEY")
        if key then
            ngx.shared.secrets:set("MINIO_SECRET_KEY", key)
            ngx.log(ngx.INFO, "[init_worker] MinIO Secret key loaded and cached")
        else
            ngx.log(ngx.ERR, "[init_worker] failed to load MINIO_SECRET_KEY!")
        end

        -- 高精度時間
        local ffi = require "ffi"
        ffi.cdef[[
            typedef long time_t;
            typedef long suseconds_t;
            typedef struct timeval {
                time_t      tv_sec;
                suseconds_t tv_usec;
            } timeval;
            int gettimeofday(struct timeval *tv, void *tz);
        ]]
    }

    # common settings
    include       "/opt/bitnami/openresty/nginx/conf/resolver.conf";
    include       mime.types;
    default_type  application/octet-stream;
    port_in_redirect off;

    # SSL configurations
    ssl_certificate /opt/bitnami/openresty/nginx/conf/certs/localhost.pem;
    ssl_certificate_key /opt/bitnami/openresty/nginx/conf/certs/localhost-key.pem;

    # Timeouts
    keepalive_timeout  65;
    sendfile           on;
    tcp_nopush         on;
    tcp_nodelay        off;
    client_max_body_size 100M;
    client_body_timeout 12;
    send_timeout 10;

    # Caching
    # open_file_cache:
    #   on  → 會快取檔案系統的 metadata/stat 結果，提升靜態檔案效能，但可能造成：
    #          - 檔案被刪掉後，FD還在，OS/NGINX 仍認為存在，直到 cache 失效才釋放
    #          - 在搭配 proxy_cache + purge 時，可能導致檔案已刪卻短暫仍回 HIT
    #          - 內容是原本cache檔案的內容
    #   off → 每次都重新檢查檔案狀態，一致性較佳，效能略降
    open_file_cache off;
    # open_file_cache max=1000 inactive=20s;
    # open_file_cache_valid 30s;
    # open_file_cache_min_uses 2;
    # open_file_cache_errors on;

    # virtual host
    vhost_traffic_status_zone;

    # Log
    map $request_uri $sanitized_request_uri {
        ~(?<prefix>.*Signature=)[^&]*(?<suffix>&?.*)    $prefix[MASKED]$suffix;
        default                                       $request_uri;
    }
    log_format masked '$remote_addr - $remote_user [$time_local] '
                      '"$request_method $sanitized_request_uri $server_protocol" $status $body_bytes_sent "$http_referer"'
                      '"$http_user_agent" "$http_x_forwarded_for" "$host" $request_time '
                      'upstream=$upstream_addr '
                      'status=$upstream_status '
                      'response_time=$upstream_response_time '
                      'cache_status=$upstream_cache_status';
    access_log "/opt/bitnami/openresty/nginx/logs/access.log" masked;
    
    # common proxy headers
    # proxy_set_header Host $host;
    # proxy_set_header X-Real-IP $remote_addr;
    # proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    # proxy_set_header X-Forwarded-Proto $scheme;

    # Custom Headers
    add_header X-Cache-Status $upstream_cache_status;
    add_header X-Served-By $hostname;

    # proxy config
    proxy_http_version 1.1;
    proxy_ssl_server_name on;

    ###
    # Server settings
    proxy_cache_path /tmp/cache levels=1:2 keys_zone=tmpcache:10m max_size=1g;

    server {
        listen 8080;
        listen 8443 ssl;

        include  "/opt/bitnami/openresty/nginx/conf/bitnami/*.conf";

        proxy_cache tmpcache;
        # 使用request_uri會包含簽章的四個參數，改用sanitized_request_uri則會對Signature做mask(需重啟)
        proxy_cache_key "$scheme$request_method$host$request_uri";
        proxy_cache_lock on;
        proxy_cache_lock_age 10s;
        proxy_cache_lock_timeout 10s;
        
        proxy_cache_valid 200 10m;

        location /metrics {
            vhost_traffic_status_display;
            vhost_traffic_status_display_format prometheus;
            vhost_traffic_status_histogram_buckets 0.005 0.01 0.05 0.1 0.5 1 5 10;
        }

        location /status {
            vhost_traffic_status_display;
            vhost_traffic_status_display_format html;
            vhost_traffic_status_histogram_buckets 0.005 0.01 0.05 0.1 0.5 1 5 10;
        }

        location = /benchmark_signer {
            content_by_lua_file lua/benchmark_signer.lua;
        }

        location = /benchmark_timer {
            content_by_lua_file lua/benchmark_timer.lua;
        }

        location = /api/keys {
            # allow 127.0.0.1;
            # deny all;
            set $cdn_enable_cors_on_failure 1;
            set $api_key_name "secdn-admin";
            access_by_lua_file lua/api_key_check.lua;
            content_by_lua_block {
                if ngx.req.get_method() ~= "GET" then
                    ngx.status = ngx.HTTP_NOT_ALLOWED
                    ngx.say("HTTP method not allowed")
                    return
                end

                local auth = require("api_key_auth")
                ngx.say("Loaded keys:")
                for _, k in ipairs(auth.list()) do
                    ngx.say("- ",k)
                end
            }
        }

        location = /lua-status {
            content_by_lua_block {
                ngx.header.content_type = "text/plain"
                ngx.say("Lua Debug Info")
                ngx.say("--------------")
                ngx.say("OpenResty Version: ", ngx.config.nginx_version)
                ngx.say("LuaJIT Version: ", jit and jit.version or "N/A")
                ngx.say("Hostname: ", ngx.var.hostname)
                ngx.say("ngx.time(): ", ngx.time())

                local vars = {
                        "request",        -- whole request line: "GET /foo HTTP/1.1"
                        "request_uri",    -- "/foo?bar=1"
                        "uri",            -- "/foo" (without args)
                        "args",           -- "bar=1"
                        "unparsed_uri",   -- (same as request_uri usually)
                        "scheme",         -- "http" or "https"
                        "host",           -- request Host header
                        "server_protocol",-- "HTTP/1.1"
                        "remote_addr",    -- client IP
                        "remote_port",    -- client port
                        "server_addr",    -- local server IP
                        "server_port",    -- local server port
                        "request_length", -- total request size
                        "query_string",   -- same as args
                }

                ngx.say("=== NGINX variable dump ===")
                for _, v in ipairs(vars) do
                        ngx.say(string.format("%-16s : %s", v, ngx.var[v] or "nil"))
                end
            }
        }

        location = /lualog {
            content_by_lua_block {
                ngx.log(ngx.ERR, "[LUA-LOG-TEST]")
            }
        }

        location /player {
            proxy_pass http://nextjs-player:3000/player;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;
            # WebSocket support for hot-reloading
            proxy_http_version 1.1;
            proxy_set_header Upgrade $http_upgrade;
            proxy_set_header Connection "Upgrade";
        }

        location /test/cookie/minio/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/cookie_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /test/cookie {
            set $api_key_name "user-a";
            access_by_lua_file lua/cookie_check.lua;
            echo "cookie ok";
        }

        location /test/signed-url-prefix/minio/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/signed_url_prefix_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /test/signed-url-prefix {
            set $api_key_name "user-a";
            access_by_lua_file lua/signed_url_prefix_check.lua;
            echo "signed url prefix ok";
        }

        location /test/signed-url-prefix/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/signed_url_prefix_check.lua;
            proxy_pass http://httpbin/;
        }

        location /test/apikey/minio/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /test/apikey {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            echo "apikey ok";
        }

        location /test/minio/ {
            proxy_pass http://127.0.0.1:8081/bucket-a/;
        }

        location /test/all/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/bucket-a/;
        }

        location /minio/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location / {
            proxy_pass http://httpbin;
            proxy_cache_purge PURGE purge_all from all;
        }

        location ~ /purge(/.*) {
            # 這裡的$1，不包含query string，只有path的部份
            # 配合 proxy_cache_key "$scheme$request_method$host$request_uri";
            # 需加上$is_args$args，可指定清除帶query string的cache
            proxy_cache_purge tmpcache $scheme$request_method$host$1$is_args$args;
        }
    }

    # private minio pucket
    upstream u_private_minio_bucket {
        keepalive 128;
        server minio:9000;
    }

    server {
        listen 127.0.0.1:8081;

        location ~ ^/([^/]+)/(.*)$ {
            set $minio_schema "http";
            set $minio_host "minio:9000";
            set $access_key "bucket-key";
            set $bucket_name $1;
            set $object_key $2;

            access_by_lua_file /opt/bitnami/openresty/nginx/lua/signer.lua;

            proxy_set_header Connection "";
            proxy_set_header Host $minio_host;
            
            proxy_pass http://u_private_minio_bucket/$bucket_name/$object_key;
        }
    }

    # include server blocks
    include  "/opt/bitnami/openresty/nginx/conf/nginx/server_blocks/*.conf";
}
