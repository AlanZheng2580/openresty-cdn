load_module modules/ngx_http_cache_purge_module.so;

worker_processes 2;

events {
    worker_connections 1024;
}

env SECDN_APIKEY_DIR;
env MINIO_SECRET_KEY;

http {
    error_log stderr info;

    lua_package_path "/opt/bitnami/openresty/nginx/lua/?.lua;;";
    # lua_code_cache off; # this will hurt performance
    lua_shared_dict secrets 1m;
    
    init_worker_by_lua_block {
        local dir = os.getenv("SECDN_APIKEY_DIR")
        local auth = require("api_key_auth")
        local ok, err = auth.load(dir)
        if ok then
            ngx.log(ngx.INFO, "[init_worker] API keys loaded and cached")
        else
            ngx.log(ngx.ERR, "[init_worker] failed to load API keys: ", err)
        end

        local key = os.getenv("MINIO_SECRET_KEY")
        if key then
            ngx.shared.secrets:set("MINIO_SECRET_KEY", key)
            ngx.log(ngx.INFO, "[init_worker] MinIO Secret key loaded and cached")
        else
            ngx.log(ngx.ERR, "[init_worker] failed to load MINIO_SECRET_KEY!")
        end

        -- 高精度時間
        local ffi = require "ffi"
        ffi.cdef[[
            typedef long time_t;
            typedef long suseconds_t;
            typedef struct timeval {
                time_t      tv_sec;
                suseconds_t tv_usec;
            } timeval;
            int gettimeofday(struct timeval *tv, void *tz);
        ]]

        local redis_util = require("redis_util")
        -- Re-define constants from waiting_room.lua for cleanup logic
        local MAX_ACTIVE_USERS = 3
        local ACTIVE_USER_TTL = 60 -- seconds, how long a user is considered active
        local QUEUE_USER_TTL = 300 -- seconds, how long a user stays in queue
        local REDIS_ACTIVE_USERS_KEY = "waiting_room:active_users"
        local REDIS_QUEUE_KEY = "waiting_room:queue"

        local function cleanup_waiting_room(premature)
            if premature then
                return
            end

            local red, err = redis_util.new()
            if not red then
                ngx.log(ngx.ERR, "Failed to get redis connection for cleanup: ", err)
                ngx.timer.at(5, cleanup_waiting_room)
                return
            end

            -- 1. Clean up expired active users
            local expired_active_score = ngx.now() - ACTIVE_USER_TTL
            local removed_active, err_rem_active = red:zremrangebyscore(REDIS_ACTIVE_USERS_KEY, "-inf", expired_active_score)
            if removed_active then
                ngx.log(ngx.INFO, "Cleanup: Removed ", removed_active, " expired active users.")
            else
                ngx.log(ngx.ERR, "Cleanup: Failed to remove expired active users: ", err_rem_active)
            end

            -- 2. Get current active users count
            local active_users_count, err_active = red:zcard(REDIS_ACTIVE_USERS_KEY)
            if not active_users_count then
                ngx.log(ngx.ERR, "Failed to get active users count from redis during cleanup: ", err_active)
                redis_util.close(red)
                ngx.timer.at(5, cleanup_waiting_room)
                return
            end

            ngx.log(ngx.INFO, "Cleanup: Current active users: ", active_users_count, ", Max: ", MAX_ACTIVE_USERS)

            -- 3. Move users from queue to active if capacity allows
            if active_users_count < MAX_ACTIVE_USERS then
                -- Get users from queue, oldest first, up to the remaining capacity
                local remaining_capacity = MAX_ACTIVE_USERS - active_users_count
                local users_to_promote, err_promote = red:zrange(REDIS_QUEUE_KEY, 0, remaining_capacity - 1) -- Get N users from the start of the queue
                if not users_to_promote then
                    ngx.log(ngx.ERR, "Failed to get users from queue for promotion: ", err_promote)
                    redis_util.close(red)
                    ngx.timer.at(5, cleanup_waiting_room)
                    return
                end

                if #users_to_promote > 0 then
                    for _, user_id in ipairs(users_to_promote) do
                        -- Atomically move user from queue to active using a Lua script for robustness
                        local script = [[
                            local user_id = ARGV[1]
                            local active_key = KEYS[1]
                            local queue_key = KEYS[2]
                            local current_time = ARGV[2]

                            local removed_from_queue = redis.call('ZREM', queue_key, user_id)
                            if removed_from_queue > 0 then
                                -- Add to active users with current time as score
                                redis.call('ZADD', active_key, current_time, user_id)
                                return 1 -- Successfully moved
                            end
                            return 0 -- Not in queue or already moved
                        ]]
                        local moved, err_moved = red:eval(script, 2, REDIS_ACTIVE_USERS_KEY, REDIS_QUEUE_KEY, user_id, ngx.now())
                        if moved == 1 then
                            active_users_count = active_users_count + 1
                            ngx.log(ngx.INFO, "Cleanup: Moved user ", user_id, " from queue to active. New active count: ", active_users_count)
                        elseif err_moved then
                            ngx.log(ngx.ERR, "Cleanup: Error moving user ", user_id, " from queue to active: ", err_moved)
                        else
                            ngx.log(ngx.INFO, "Cleanup: User ", user_id, " was not in queue or already moved.")
                        end
                    end
                end
            end

            redis_util.close(red)

            local ok, err_timer = ngx.timer.at(5, cleanup_waiting_room)
            if not ok then
                ngx.log(ngx.ERR, "failed to create timer: ", err_timer)
            end
        end

        -- Start the cleanup timer
        local ok, err = ngx.timer.at(0, cleanup_waiting_room) -- Run immediately and then every 5 seconds
        if not ok then
            ngx.log(ngx.ERR, "failed to start initial cleanup timer: ", err)
        end
    }

    resolver 127.0.0.11 ipv6=off;  # 這行是關鍵！

    upstream u_private_minio_bucket {
        keepalive 128;
        server minio:9000;
    }

    proxy_cache_path /tmp/cdn_test levels=1:2 keys_zone=cdn_test:1m max_size=1g inactive=365d;
    server {
        listen 8080;

        proxy_cache cdn_test;
        proxy_cache_key "$scheme$request_method$host$request_uri";
        add_header X-Cache-Status $upstream_cache_status;

        location = /benchmark_signer {
            content_by_lua_file /opt/bitnami/openresty/nginx/lua/benchmark_signer.lua;
        }

        location = /waiting_room.html {
            root /opt/bitnami/openresty/nginx/html;
        }

        location = /benchmark_timer {
            content_by_lua_file /opt/bitnami/openresty/nginx/lua/benchmark_timer.lua;
        }

        location = /api/keys {
            # allow 127.0.0.1;
            # deny all;
            set $api_key_name "secdn-admin";
            access_by_lua_file lua/api_key_check.lua;
            content_by_lua_block {
                if ngx.req.get_method() ~= "GET" then
                    ngx.status = ngx.HTTP_NOT_ALLOWED
                    ngx.say("HTTP method not allowed")
                    return
                end

                local auth = require("api_key_auth")
                ngx.say("Loaded keys:")
                for _, k in ipairs(auth.list()) do
                    ngx.say("- ",k)
                end
            }
        }

        location = /lua-status {
            content_by_lua_block {
                ngx.header.content_type = "text/plain"
                ngx.say("Lua Debug Info")
                ngx.say("--------------")
                ngx.say("OpenResty Version: ", ngx.config.nginx_version)
                ngx.say("LuaJIT Version: ", jit and jit.version or "N/A")
                ngx.say("Hostname: ", ngx.var.hostname)
            }
        }

        location = /waiting_room_status {
            content_by_lua_file lua/waiting_room.lua;
        }

        location /test/apiauth {
            set $secdn_auth_request_url "http://js-auth:2345/auth";
            access_by_lua_file lua/api_check.lua;
            echo "/test/apiauth, API Auth is valid";
        }

        location /test/cookie {
            set $api_key_name "user-a";
            access_by_lua_file lua/cookie_check.lua;
            echo "/test/cookie, Cookie is valid";
        }

        location /test/apikey {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            echo "/test/apikey, API Key is valid";
        }

        location /test/minio/ {
            proxy_pass http://127.0.0.1:8081/bucket-a/;
        }

        location /test/all/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/bucket-a/;
        }

        location /minio/apiauth/ {
            set $secdn_auth_request_url "http://js-auth:2345/auth";
            access_by_lua_file lua/api_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /minio/cookie/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/cookie_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /minio/apikey/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location /minio/ {
            set $api_key_name "user-a";
            access_by_lua_file lua/api_key_check.lua;
            proxy_pass http://127.0.0.1:8081/;
        }

        location / {
            content_by_lua_file lua/waiting_room.lua;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_valid 200 7d;
            proxy_cache_purge PURGE purge_all from all;
        }

        location @proxy_to_httpbin {
            internal;
            proxy_pass http://httpbin;
            proxy_cache_use_stale error timeout updating http_500 http_502 http_503 http_504;
            proxy_cache_valid 200 7d;
            proxy_cache_purge PURGE purge_all from all;
        }
    }

    server {
        listen 127.0.0.1:8081;

        location ~ ^/([^/]+)/(.*)$ {
            set $minio_schema "http";
            set $minio_host "minio:9000";
            set $access_key "bucket-key";
            set $bucket_name $1;
            set $object_key $2;

            access_by_lua_file /opt/bitnami/openresty/nginx/lua/signer.lua;
            proxy_set_header Host minio:9000;
            proxy_pass http://u_private_minio_bucket/$bucket_name/$object_key;
        }
    }
}
